<?xml version="1.0" encoding="UTF-8"?>

<mule xmlns:mulerequester="http://www.mulesoft.org/schema/mule/mulerequester" xmlns:file="http://www.mulesoft.org/schema/mule/file"
	xmlns:ftp="http://www.mulesoft.org/schema/mule/ftp" xmlns:jms="http://www.mulesoft.org/schema/mule/jms"
	xmlns:json="http://www.mulesoft.org/schema/mule/json" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:http="http://www.mulesoft.org/schema/mule/http" xmlns="http://www.mulesoft.org/schema/mule/core"
	xmlns:doc="http://www.mulesoft.org/schema/mule/documentation"
	
	xmlns:spring="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.mulesoft.org/schema/mule/file http://www.mulesoft.org/schema/mule/file/current/mule-file.xsd
http://www.mulesoft.org/schema/mule/json http://www.mulesoft.org/schema/mule/json/current/mule-json.xsd
http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-current.xsd
http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
http://www.mulesoft.org/schema/mule/http http://www.mulesoft.org/schema/mule/http/current/mule-http.xsd
http://www.mulesoft.org/schema/mule/jms http://www.mulesoft.org/schema/mule/jms/current/mule-jms.xsd
http://www.mulesoft.org/schema/mule/ftp http://www.mulesoft.org/schema/mule/ftp/current/mule-ftp.xsd
http://www.mulesoft.org/schema/mule/mulerequester http://www.mulesoft.org/schema/mule/mulerequester/current/mule-mulerequester.xsd">

	<context:property-placeholder location="classpath*:dp_ps${mule.env:#{null}}.properties"
		system-properties-mode="OVERRIDE" />
	<spring:beans>
		<spring:bean id="psProps"
			class="org.springframework.beans.factory.config.PropertiesFactoryBean">
			<spring:property name="singleton" value="true" />
			<spring:property name="location" value="classpath:dp_ps${mule.env:#{null}}.properties" />
		</spring:bean>
	</spring:beans>

	<http:listener-config name="HTTP_Listener_Configuration"
		host="${dp.ps.host}" port="${dp.ps.port}" basePath="${dp.ps.path}"
		doc:name="HTTP Listener Configuration" />
	<http:request-config name="HTTP_Request_Elastisearch"
		host="${elasticsearch.host}" port="${elasticsearch.rest.port}"
		basePath="${elasticsearch.sentinel.path}" doc:name="HTTP Request Elastisearch" />
	<jms:activemq-connector name="Active_MQ"
		validateConnections="true" doc:name="Active MQ" brokerURL="tcp://127.0.0.1:61616" persistentDelivery="true"/>
	
	<mulerequester:config name="Mule_FTP_Requester" doc:name="Mule Requester"/>
    <!-- FtpConnector with streaming=true to avoid original file deletion! (created to be used with mulerequester) -->
    <ftp:connector name="nonDeletingFtpConn" doc:name="FTP Connector with streaming set to true to avoid original file deletion! (created to be used with mulerequester)" pollingFrequency="1000" validateConnections="true" streaming="true">	
    	<!-- <dispatcher-threading-profile doThreading="false"/> -->
    </ftp:connector>
    
    <!-- Add needed orchestrator properties to the JMS message to pass them to LogStash -->
    <message-properties-transformer name="Logstash-Properties" doc:name="Message Properties">
        <add-message-property key="orchestratorId" value="#[orchestratorId]"/>
        <add-message-property key="datasetId" value="#[datasetId]"/>
        <add-message-property key="timeToLive" value="${dp.ps.jms.timetolive}"/>
    </message-properties-transformer>
    <!-- Set specific JMS (and then Logstash) properties depending on the specific processing level -->
    <message-properties-transformer name="S0-Properties" doc:name="Message Properties">
    	<add-message-property key="step" value="S0"/>
    </message-properties-transformer>
    <message-properties-transformer name="S1-Properties" doc:name="Message Properties">
    	<add-message-property key="step" value="S1"/>
    </message-properties-transformer>
    <message-properties-transformer name="S2-Properties" doc:name="Message Properties">
    	<add-message-property key="step" value="S2"/>
    </message-properties-transformer>
    

	<flow name="dp_psFlow">
		<http:listener config-ref="HTTP_Listener_Configuration"
			path="/" allowedMethods="POST" doc:name="Receive new Sen1 acquisitions">
			<http:response-builder statusCode="200" />
		</http:listener>
        <object-to-string-transformer doc:name="Object to String"/>
        <set-variable variableName="savePayload" value="#[payload]" doc:name="savePayload"/>
		<async doc:name="Async">
            <set-payload value="#[savePayload]" doc:name="Set Payload"/>
            <logger message="New Sen1 acquisitions" level="INFO" doc:name="New Sen1 acquisitions"/>
            <logger message="Acquisitions payload: #[payload]" level="DEBUG" doc:name="Acquisitions payload"/>
			<json:json-to-object-transformer
				returnClass="java.util.ArrayList" doc:name="JSON to ArrayList" />
			<set-variable variableName="datasetSet" value="#[new java.util.HashSet()]"
				doc:name="init datasetSet" />
			<foreach doc:name="For Each new data">
				<set-variable variableName="datasetId"
					value="#[payload.get(&quot;datasetId&quot;)]" doc:name="Extract data datasetId" />
				<expression-filter expression="!datasetSet.contains(datasetId)"
					doc:name="Filter NOT yet processed dataset" />
				<expression-component doc:name="add datasetId to datasetSet"><![CDATA[datasetSet.add(datasetId);]]></expression-component>
				<set-payload
					value="{ &quot;query&quot;: { &quot;match&quot;: {&quot;datasetId&quot;:&quot;#[datasetId]&quot; } } }"
					doc:name="Get full data list for current dataset" />
				<flow-ref name="elasticSearchFlow" doc:name="elasticSearchFlow" />
                <logger message="Launching processing flow for dataset #[datasetId]" level="INFO" doc:name="Process Dataset"/>
				<flow-ref name="dp_ps_datasetFlow" doc:name="dp_ps_datasetFlow" />
			</foreach>
			<logger message="End" level="INFO" doc:name="End" />
		</async>
		<set-payload value="200 OK" doc:name="HTTP return" />
        <choice-exception-strategy doc:name="Choice Exception Strategy">
            <catch-exception-strategy when="exception.causedExactlyBy(org.mule.api.routing.filter.FilterUnacceptedException)" enableNotifications="false" doc:name="Catch JMS message-failed">
                <logger message="Processor failure from orchestratorId &quot;#[orchestratorId]&quot; for dataset &quot;#[datasetId]&quot;, cause: &quot;#[message.inboundProperties.'message_failed']&quot;" level="ERROR" doc:name="Processor failure from JMS"/>
                <logger level="DEBUG" doc:name="Full Message" message="Full message: #[message]"/>
            </catch-exception-strategy>
            <catch-exception-strategy when="exception.causedExactlyBy(org.mule.api.routing.ResponseTimeoutException)" doc:name="Catch JMS reply timeout">
                <logger message="JMS reply timed out for request in &quot;#[message.outboundProperties['MULE_ENDPOINT']]&quot;  from orchestratorId &quot;#[orchestratorId]&quot; for dataset &quot;#[datasetId]&quot;" level="ERROR" doc:name="JMS Reply Timeout (managed by activeMQ DLQ)"/>
                <logger message="Full message: #[message]" level="DEBUG" doc:name="Full Message"/>
            </catch-exception-strategy>
        </choice-exception-strategy>
	</flow>
	
	
	<sub-flow name="dp_ps_datasetFlow">
		<logger message="DATASETID: #[datasetId]" level="INFO"
			doc:name="Show datasetId" />
		<set-variable variableName="datasetDataArrayList" value="#[payload]"
			doc:name="save datasetDataArrayList" />
        <set-variable variableName="orchestratorId" value="#[java.util.UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;)]" doc:name="orchestratorId"/>
        <logger message="orchestratorId: #[orchestratorId]" level="INFO" doc:name="orchestratorId"/>

		<set-payload
			value="{  &quot;query&quot;: {    &quot;bool&quot;: {      &quot;must&quot;: [        { &quot;match&quot;: { &quot;datasetId&quot;:  &quot;#[datasetId]&quot; }},        { &quot;match&quot;: { &quot;superMaster&quot;: &quot;true&quot;   }}      ]    }  }}"
			doc:name="Query getsuperMaster" />
		<http:request config-ref="HTTP_Request_Elastisearch"
			path="/_search" method="POST" doc:name="ElasticSearch" />
		<set-variable variableName="resSize" value="#[json:hits/total]"
			doc:name="resSize" />
		<choice doc:name="SuperMaster exists?">
			<when expression="#[resSize.equals('1') ]">
				<logger message="***********SuperMaster exist**************"
					level="INFO" doc:name="SuperMaster exist" />
				<set-variable variableName="superMasterId"
					value="#[json:hits/hits[0]/_source/uuid]" doc:name="superMasterId" />
			</when>
			<otherwise>
				<logger message="***********SuperMaster not exist**************"
					level="INFO" doc:name="SuperMaster not exist" />
				<set-payload value="#[datasetDataArrayList]" doc:name="Set Payload to datasetDataArrayList" />
				<json:object-to-json-transformer
					doc:name="ArrayList to JSON" />
				<logger message="**********Call Processor Calculate SuperMaster"
					level="INFO" doc:name="Call SuperMaster Processor" />

				<request-reply doc:name="Request-Reply" timeout="0">
				
					<jms:outbound-endpoint queue="rheticus.processor.ps.s0.request" connector-ref="Active_MQ" doc:name="ps.request S0" transformer-refs="Logstash-Properties S0-Properties"/>
					<jms:inbound-endpoint queue="rheticus.processor.ps.s0.reply" connector-ref="Active_MQ" doc:name="ps.reply S0">
						
					</jms:inbound-endpoint>
				</request-reply>
                <object-to-string-transformer doc:name="Object to String"/>
                <logger level="INFO" doc:name="S0 out" message="S0 out: #[payload]"/>
                <message-filter throwOnUnaccepted="true" doc:name="If not message_failed (else Exception!)">
                    <message-property-filter pattern="message_failed=null" caseSensitive="true" scope="inbound"/>

                </message-filter>
                <set-variable variableName="superMasterId" value="#[json:superMasterId]" doc:name="superMasterId"/>

                <set-payload value="{    &quot;doc&quot; : {        &quot;superMaster&quot; : true    }}" doc:name="Update SM value"/>
                <http:request config-ref="HTTP_Request_Elastisearch" path="/#[superMasterId]/_update" method="POST" doc:name="ElasticSearch"/>
			</otherwise>
		</choice>
		<logger message="********superMasterId: #[superMasterId]"
			level="INFO" doc:name="superMasterId" />
		<logger message="*********Create Json for S1TB**********"
			level="INFO" doc:name="Create Json for S1TB" />
		<set-variable variableName="mapForS1TB" value="#[new java.util.HashMap()]"
			doc:name="mapForS1TB" />
		<expression-component doc:name="populate mapForS1TB"><![CDATA[mapForS1TB.put("datasetId", datasetId);
mapForS1TB.put("supermasterId", superMasterId);
mapForS1TB.put("data", datasetDataArrayList);
]]></expression-component>
		<set-payload value="#[mapForS1TB]" doc:name="mapForS1TB" />
		<json:object-to-json-transformer
			doc:name="Object to JSON" />
		<logger message="******Call S1TB " level="INFO" doc:name="Call S1TB " />

		<request-reply doc:name="Request-Reply" timeout="0">
			<jms:outbound-endpoint queue="rheticus.processor.ps.s1.request" connector-ref="Active_MQ" doc:name="ps.request S1" transformer-refs="Logstash-Properties S1-Properties"/>
			<jms:inbound-endpoint queue="rheticus.processor.ps.s1.reply"	connector-ref="Active_MQ" doc:name="ps.reply S1" >
					
			</jms:inbound-endpoint>
		</request-reply>
		<message-filter throwOnUnaccepted="true" doc:name="If not message_failed (else Exception!)">
            <message-property-filter pattern="message_failed=null" caseSensitive="true" scope="inbound"/>

        </message-filter>
		<object-to-string-transformer doc:name="Object to String" />

		<logger message="S1TVB Request response:  #[payload]" level="INFO"
			doc:name="Result S1TB" />
		
		<logger message="******Call PSinSAR " level="INFO" doc:name="Call PSinSAR" />

		<request-reply doc:name="Request-Reply" timeout="0">
			<jms:outbound-endpoint queue="rheticus.processor.ps.s2.request" connector-ref="Active_MQ" doc:name="ps.request S2" transformer-refs="Logstash-Properties S2-Properties"/>
			<jms:inbound-endpoint queue="rheticus.processor.ps.s2.reply"	connector-ref="Active_MQ" doc:name="ps.reply S2" >
					
			</jms:inbound-endpoint>
		</request-reply>
		<message-filter throwOnUnaccepted="true" doc:name="If not message_failed (else Exception!)">
            <message-property-filter pattern="message_failed=null" caseSensitive="true" scope="inbound"/>

        </message-filter>
		<object-to-string-transformer doc:name="Object to String" />

		<logger message="PSinSAR Request response:  #[payload]" level="INFO" doc:name="Result PSinSAR" />
		<json:json-to-object-transformer returnClass="java.util.ArrayList" doc:name="JSON to ArrayList"/>
        <foreach doc:name="For Each">
            <set-variable variableName="fileName" value="#[payload.substring(payload.lastIndexOf(&quot;/&quot;))]" doc:name="fileName"/>
            <mulerequester:request config-ref="Mule_FTP_Requester" resource="#[payload]?connector=nonDeletingFtpConn" doc:name="Download PS map from FTP"/>
            <logger message="Requester: #[message]" level="INFO" doc:name="Logger"/>
            <file:outbound-endpoint path="${import.shapefile.folder}" outputPattern="#[fileName]" responseTimeout="10000" doc:name="Download to import dir"/>
            <expression-filter expression="#[fileName.endsWith(&quot;.shp&quot;)]" doc:name="is .shp?"/>
            <set-variable variableName="shapefileName" value="#[fileName]" doc:name="shapefileName"/>
        </foreach>
		<component class="it.planetek.rheticus.mule.components.LauncherKettleJob" doc:name="Load shape through Geokettle"/>
        <logger message="Geokettle output: #[payload]" level="INFO" doc:name="Geokettle output"/>
        <logger message="END Orchestrator dp_ps" level="INFO" doc:name="End dp_ps"/>
	</sub-flow>
</mule>
